

# 基础

## 函数

### 值传递机制

- 形式参数在函数调用的时候才会创建存储空间，并接受实际参数的值；
- 实际参数可以为复杂的表达式，在函数调用前获得计算；
- 形式参数与实际参数可同名，也可不重名；
- 参数较多时候，实际参数值逐一赋值，它必须保持数目、类型、顺序一致；
- 值得赋值过程是单向不可逆的，函数内部对形式参数值的修改不会反映到实际参数中去；
- 函数参数一般为函数输入集的一部分，函数输出集一般使用返回值表示，只有使用特殊的手段才可以将函数参数作为函数输出集的一部分；

#### Task：

- [x] 编写函数IsPrime，判断某个大于2的正整数是否为素数；

- [x] 编写函数gcd与lcm，分别求两个正整数的最大公约数与最小公倍数；

### 引用传递机制



## 宏定义

```c++
#ifndef DEBUG
// code，using，if before not use #define DEBUG, will execute this code，else jump this code. 
#endif
```



## 指针

### 指针运算

指针运算操作是以指针指向的目标数据对象类型为单位

```c++
int* p;
// 表示的指针p先做*p运算赋值，之后做的是p++运算（指针后移一个数据类型int单位指向下一个int存放的地址）
*p++ = generateNum() 
```

### 指针与数组

指针与数据是计算格式是一样的，但是二者不是相同的，指针可以做\*p++，数组无法做\*a++



## 字符串



## 动态分配

专门在堆中存放动态分配的数据，c中使用malloc和free函数，c++增加了new和delete操作符，c方式分配内存使用c方式释放内存，c++也一样。

### C++中增加的动态分配方式

#### new/new[]

分配单个目标对：int*p; p = new int; *p = 10;

分配多个目标对象：int* p; p = new int[8];

#### delete/delete[]

释放单个对象：int* p; p = new int; *p = 10; delete p;

释放多个对象：int* p; p =  new int[10]; delete[] p;

### void*类型

哑型指针，暂时不确定类型，使用这个。



## 引用

### 引用的定义

定义格式：数据类型& 变量名称 = 被应用比那辆名称；

示例：int a; int & ref = a;

### 引用的性质

引用类型的变量不占用单独的存储空间

为另一数据对象起个别名，与该对象共享存储空间

### 特殊说明

引用类型的变量必须在定义时初始化

此关联关系在引用类型变量的整个存续期都保持不变

对引用类型变量的操作就是对被引用变量的操作

### 引用作为函数参数

参数传递机制：引用传递，直接修改实际参数值。

```c++
void Swap(int & x, int & y) {
    int t;
    t = x;
    x = y;
    y = t;
    return;
}

int main() {
    int a = 10;
    int b = 20;
    Swap(a, b); // a和b的值都互换了
}
```



## 数据抽象

### 数据抽象

信息缺失：程序中的数据对象只有地址和值，没有数据类型、数据名称数据解释以及数据意义等信息

解决手段：抽象

### 结构化数据类型的性质

- 类型：细节由用户自定义，语言仅提供定义手段
- 成员：结构化数据类型的子数据对象
- 成员类型：每个成员具有确切的类型
- 成员数目：部分结构化数据类型可变，部分固定
- 成员组织：成员组织结构（线性结构或非线性结构）必须显示定义
- 操作集：可以在数据上进行的操作集合

### 数据封装

数据封装：将数据结构和细节隐藏起来

实现方式：分别实现访问数据成员的存取函数

### 信息隐藏

#### 数据封装的问题

只要将结构体定义在头文件中，库的使用者就可以看到该定义，并按照成员格式直接访问，而不调用存取函数

#### 解决方法

将结构体类型的具体细节定义在源文件中，所有针对该类型量的操作都只能通过函数接口来进行，从而隐藏实现细节

#### 信息隐藏示例：

```c++
/* 头文件 "dynarryn.h" */
struct DYNINTS; typedef struct DYNINTS * PDYNINTS;

/* 源文件 "dynarray.cpp" */
struct DYNINTS {
    unsigned int capacity;
    unsigned int count;
    int * items;
    bool modified;
};
```



### 抽象数据类型



## 链表



## 函数指针

用处：函数指针可用于函数回调上，通过作为参数传递到函数参数列表中，函数调用参数列表中的函数指针，然后调用函数指针所指向所对应的函数入口地址调用函数。这样函数指针所指向的函数与调用它的函数进行了解耦，其中一方定义目标函数还有一方可以自己定义回调函数，这样就是回调。

## 抽象链表



## 类

类的概念和意义：

- 属性与行为的辩证统一

程序抽象

- 数据封装、信息隐藏
- 如果没有类的概念，无法定义非指针量，且控制性不佳

对象的概念与意义

- 量
- 对象行为的主动性

### 类的声明与定义

```c++
class A {
    public:
    	成员变量 成员函数（可以多行的，不用加花括号）
    protected:
    	成员变量 成员函数
    private:
    	成员变量 成员函数（成员变量或成员函数没有加修饰符号，则默认是private的）
}
```

### 类函数的实现

```c++
/* a.h */
class B;
class A {
    public:
    	int GetX();
    	void func(B b); //正确
    private:
    	int x;
    	B b; //错误，内存分配的模式不知道，所以类类型的声明是不能用于数据成员的定义。
}

/* a.cpp */
#include "a.h"
int A::GetX() {
    reutrn this->x;
}
```

### 对象

在类的声明中有3个缺省的函数：

- 缺省的构造函数
- 缺省的拷贝构造函数
- 缺省的析构函数
- 函数

#### 构造函数的初始化列表

```c++
// 构造函数的初始化列表格式
class A
{
    public:
     A(int a);
    private a;
};

class B
{
    public:
     B(int a, int b);
    private:
     A a;
     int b;
};

// 实现构造
A::A(int a) : a(a)
{
    
}

B::B(A a, int b) : a(a), b(b)
{
    
}

```



##### 构造函数初始化的目的意义

- 在构造对象时，同步构造内部对象
- 部分成员（常量与引用）只能初始化，不嗯给你赋值
- 部分成员（类的对象）如果复制，将导致两次构造
  - 在分配内存时，调用缺省构造函数构造，然后执行构造函数体内的赋值语句再次构造，效率不佳
  - 若类没有缺省构造函数，则会导致问题

##### 注意事项

- 成员初始化按照成员定义顺序，而不是初始化列表顺序
- 必须保持初始化列表和成员定义的顺序一致性，但允许跳过部分成员；否则后续成员可能不会正确初始化

#### 对象的析构

##### 对象析构的意义

- 析构就是终止化，在对象生命周期结束时清除它

##### 对象析构的技术手段：使用析构函数

- 与类类型同名， 前有“~”记号，无返回值类型（包括void类型），无参数
- 析构函数必须公开（某些情况下也可以不公开）
- 可以由系统在销毁对象时自动调用，也可以由程序其他部分直接调用，但两者工作原理不同
- 每个类的析构函数只能有一个
- 若未定义，系统会自动产生一个缺省析构函数，该函数无代码

##### 定义析构函数的目的

- 用于释放对象中动态分配内存的目标数据对象

  ```c++
  // example
  class A{
      public:
       A(int x);
       ~A();
      private:
       int *p;
  };
  
  // 实现
  A::A(int x)
  {
      p = new int;
      *p = x;
  }
  
  A::~A()
  {
      delete p, p = NULL;
  }
  ```

#### 对象数组

- 像普通数组一样定义使用

##### 对象数组的初始化

- 当构造函数单参数时，像普通数组一样构造所有元素

- 当构造函数多参数时，使用下述方法构造

  ```c++
  Circle circles[2] =  {Circle(1.0, 0.0, 0.0), Circle(2.0, 1.0, 1.0)};
  ```

### 类与对象的成员



### 继承

### 多态

### 编程实践



## 操作符重载

### 四则运算符重载

### 关系与下标操作符重载

### 赋值操作符重载

### 流操作符重载

### 操作符重载总结

### 编程实践



## 泛型编程

### 异常处理机制

### 运行期型式信息

### 模板与型式参数化

### 泛型编程实践

### 编程实践



## 程序环境

### 程序执行环境

### 输入输出

### 文件系统

### 设备

### 库

### makefile文件

### 编程实践



## 进程

### 进程基本概念

### 信号

### 进程管理

### 进程间通信

### 进程池

### 编程实践



## 线程

### 线程基本概念

### 线程管理

### 线程同步机制

### C++11线程库

### 编程实践



## 网络

### Internet网络协议

### 套接字

### 编程实践

